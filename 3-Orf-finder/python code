#Input : genome sequence
DNA=input("Enter a DNA sequence:")
dna=DNA.lower()


#Make complementary sequence
def reverse_complement(dna):
     complement = {'a': 't', 'c': 'g', 'g': 'c', 't': 'a'}
     return ''.join([complement[base] for base in dna[::-1]]) #상보적 서열
reverse_dna=reverse_complement(dna)


#Decompose sequence into triplets(make 6 frames)
frame1=[dna[i:i+3] for i in range(0,len(dna),3)] #+1 frame
frame2=[dna[i:i+3] for i in range(1,len(dna),3)] #+2 frame
frame3=[dna[i:i+3] for i in range(2,len(dna),3)] #+3 frame
frame4=[reverse_dna[i:i+3] for i in range(0,len(reverse_dna),3)] #-1 frame
frame5=[reverse_dna[i:i+3] for i in range(1,len(reverse_dna),3)] #-2 frame
frame6=[reverse_dna[i:i+3] for i in range(2,len(reverse_dna),3)] #-3 frame


#3개 nucleotide로 떨어지지 않는 마지막 지우기
if len(frame1[-1])<3:
    del frame1[-1]
if len(frame2[-1])<3:
    del frame2[-1]
if len(frame3[-1])<3:
    del frame3[-1]    
if len(frame4[-1])<3:
    del frame4[-1]    
if len(frame5[-1])<3:
    del frame5[-1]    
if len(frame6[-1])<3:
    del frame6[-1]
    

#Codon definition(3 nucleotide → amino acid)
codon_table = {'ttt': 'F', 'ttc': 'F', 'tta': 'L', 'ttg': 'L', 'tct': 'S','tcc': 'S', 'tca': 'S', 'tcg': 'S', 'tat': 'Y', 'tac': 'Y', 'taa':'*','tag':'*', 'tga':'*', 
'tgt': 'C', 'tgc': 'C', 'tgg': 'W', 'ctt': 'L', 'ctc': 'L', 'cta': 'L', 'ctg': 'L', 'cct': 'P', 'ccc': 'P', 'cca': 'P', 'ccg': 'P', 'cat': 'H', 'cac': 'H', 'caa': 'Q', 
'cag': 'Q','cgt': 'R', 'cgc': 'R', 'cga': 'R', 'cgg': 'R', 'att': 'I', 'atc': 'I', 'ata': 'I','atg': 'M', 'act': 'T', 'acc': 'T','aca': 'T', 'acg': 'T', 'aat': 'N',
'aac': 'N', 'aaa': 'K','aag': 'K', 'agt': 'S', 'agc': 'S', 'aga': 'R', 'agg': 'R','gtt': 'V', 'gtc': 'V', 'gta': 'V', 'gtg': 'V', 'gct': 'A','gcc': 'A', 'gca': 'A', 
'gcg': 'A', 'gat': 'D','gac': 'D','gaa': 'E', 'gag': 'E', 'ggt': 'G', 'ggc': 'G', 'gga': 'G','ggg': 'G'}

#사용자가 codon table 생성
dict_list = []
while True :
    sel = int(input('1번은 코돈 입력 계속, 2번은 종료 : '))
    if sel == 1 :
        print("===== 코돈 추가 중 =====")
        my_dict = {} # empty dictionary
        while True :
            key = input('codon 입력 : ')
            val = input('amino acid 입력 : ')
            my_dict[key] = val
            con = int(input('1번은 딕셔너리 요소 추가 계속, 2번은 종료 : '))
            if con == 2 :
                print("===== 코돈 추가 끝 =====", end="\n\n")
                break
        dict_list.append(my_dict)
    elif sel == 2 :
        print("종료합니다.")
        break
    else :
        print("잘못 선택하셨습니다.")
        break
print("당신이 만든 codon table :", dict_list)
               
#frame traslation
f1=[codon_table[i] for i in frame1[:]]
frame1_codon = ''.join(f1)
f2=[codon_table[i] for i in frame2[:]]
frame2_codon = ''.join(f2)
f3=[codon_table[i] for i in frame3[:]]
frame3_codon = ''.join(f3)
f4=[codon_table[i] for i in frame4[:]]
frame4_codon = ''.join(f4)
f5=[codon_table[i] for i in frame5[:]]
frame5_codon = ''.join(f5)
f6=[codon_table[i] for i in frame6[:]]
frame6_codon = ''.join(f6)


#ORF find
def splitAndSearch(sequence, seperator, starter) :
    splited = sequence.split(seperator)[0] + seperator

    print("탐색할 서열 : " + splited)

    # indexList = []
    patterns = []
    for i in range(len(splited)) : 
        if splited[i] == starter : 
            patterns.append(splited[i:])

    print("발견된 서열: " )
    for str in patterns : 
        print(str, len(str)*3)

entered_seq1 = frame1_codon
entered_seq2 = frame2_codon
entered_seq3 = frame3_codon
entered_seq4 = frame4_codon
entered_seq5 = frame5_codon
entered_seq6 = frame6_codon
seperator = '*' 
start_ch = 'M' 
splitAndSearch(frame1_codon, seperator, start_ch)
splitAndSearch(frame2_codon, seperator, start_ch)
splitAndSearch(frame3_codon, seperator, start_ch)
splitAndSearch(frame4_codon, seperator, start_ch)
splitAndSearch(frame5_codon, seperator, start_ch)
splitAndSearch(frame6_codon, seperator, start_ch)


#ORF length distribution
import matplotlib.pyplot as plt
length= [405, 390, 345, 186, 48, 108]
plt.hist(length, bins=10)
plt.show()
print(max(length)) #가장 긴 ORF 


#여기서부터는 사용하지 않음
#stop codon site
stop_codon_site1=frame1_codon.find('*')
stop_codon_site1


#start codon~stop codon
i=0
while i < stop_codon_site1 :
    i=i+1
    if frame1_codon[i] == 'M':
        fr1=(frame1_codon[i:stop_codon_site1]) #amino acid seq
        fr1_s=(frame1[i:stop_codon_site1+1]) 
        fr1_seq=''.join(fr1_s) #DNA seq

import matplotlib.pyplot as plt

def read_fasta(filename):
	output = {}
	fasta_file = open(filename)

	for line in fasta_file:
		line = line.rstrip()
		if line.startswith('>'):
			sequence_name = line[1:]
			output[sequence_name] = ''
			continue
		else:
			output[sequence_name] += line

	fasta_file.close()

	return output


def reverse_complement(sequence):
	complement = {'A' : 'T', 'T' : 'A', 'G' : 'C', 'C' : 'G'}

	return ''.join([complement[base] for base in sequence])[::-1]


def find_orf(frame, allow_nested = 'Y'):
	frame_codon = [D_codon[tri] for tri in frame if tri in D_codon]
	frame_trans = ''.join(frame_codon)

	start_site = []
	index = -1
	while True:
		index = frame_trans.find('M', index + 1)
		if index == -1:
			break
		start_site.append(index)

	output = []
	orf_end = 0

	for site in start_site:
		if allow_nested != 'Y':
			if site < orf_end:
				continue

		frame_cut = frame_trans[site:]

		if '*' not in frame_cut:
			continue

		stop_codon = frame_cut.find('*') + site + 1
		orf_sequence = ''.join(frame[site:stop_codon])
		amino_sequence = frame_cut.split('*')[0]

		output.append((orf_sequence, amino_sequence))
		orf_end = site + len(amino_sequence) + 1

	return output


D_codon = {}
codon_table = open('codon.txt')

for line in codon_table:
	line = line.rstrip()
	line_split = line.split('\t')

	for block in line_split:
		block_split = block.split(' ')
		codon = block_split[0]
		amino_acid = block_split[1]

		D_codon[codon] = amino_acid

input_fasta = read_fasta('example.fasta')
output = open('output2.txt','w')

minimum_length = 300
length_list = []

for sequence_name, sequence in input_fasta.items():
	sequence_reverse = reverse_complement(sequence)

	for repeat in range(6):
		if repeat < 3:
			frame = [sequence[i:i+3] for i in range(repeat%3, len(sequence), 3)] # forward
		else:
			frame = [sequence_reverse[i:i+3] for i in range(repeat%3, len(sequence), 3)] # reverse

		if repeat < 3:
			frame_number = '+%s' % (repeat + 1)
		else:
			frame_number = 2 - repeat

		orf_list = find_orf(frame, 'Y')
		for orf in orf_list:
			nt = orf[0]
			aa = orf[1]
			if len(nt) <= minimum_length:
				continue
			output.write('>%s|%s\n%s\n%s*\n' % (sequence_name, frame_number, nt, aa))
			length_list.append(len(nt))

plt.hist(length_list, bins=10)
plt.show()
